import pygame as pg
from heapq import *
import random
import sys

#если при старте мышь вне окна - появляется ошибка, так как не срабатывает переменная для определения позиции мыши. Исправить. Скорее всего через except

#переменные
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (125, 125, 125)
LIGHT_BLUE = (64, 128, 255)
GREEN = (0, 200, 64)
YELLOW = (225, 225, 0)
PINK = (230, 50, 230)
ForestGreen = (34, 139, 34)
RED = (255, 0, 0)

cols, rows = 33, 23 #количество клеток по горизонтали и вертикали
TILE = 50 #размер клетки

#временные переменные
speed = 20 #нужна для теста переменещения. Потом заменить на скорость персонажей
start = (0, 7) #стартовая позиция. Потом заменить на позицию при размещении персонажей

#начало поля. Это на будущее для общего смещения поля
mainfield_X = 0
mainfield_Y = 0

#матрица проходимости. Каждое число - шкала X.
grid = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],[], [], [], [], [], [], [], [], [], []]
#матрица клеток. Каждое число - шкала X.
field = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],[], [], [], [], [], [], [], [], [], []]
#матрица картинок. Каждое число - шкала X.
field_images = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],[], [], [], [], [], [], [], [], [], []]

#функция создания круга для "змейки"
def get_circle(x, y):
    return (x * TILE + TILE // 2, y * TILE + TILE // 2), TILE // 4

#определить соседние клетки
def get_neighbours(x, y):
    check_neighbour = lambda x, y: True if 0 <= x < cols and 0 <= y < rows else False
    ways = [-1, 0], [0, -1], [1, 0], [0, 1], [-1, -1], [1, -1], [1, 1], [-1, 1]
    return [((grid[y + dy][x + dx]), (x + dx, y + dy)) for dx, dy in ways if check_neighbour(x + dx, y + dy) and (grid[y + dy][x + dx]) != '-']

    #return [((grid[y + dy][x + dx]), (x + dx, y + dy)) for dx, dy in ways if check_neighbour(x + dx, y + dy) and (grid[y + dy][x + dx]) != '-']





def get_click_mouse_pos():
    x, y = pg.mouse.get_pos()
    grid_x, grid_y = x // TILE, y // TILE
    #pg.draw.circle(sc, pg.Color('red'), *get_circle(grid_x, grid_y)) #рисует круг на месте клика мыши
    click = pg.mouse.get_pressed()
    return (grid_x, grid_y) if click[0] else False

def get_mouse_pos():
    x, y = pg.mouse.get_pos()
    grid_x, grid_y = x // TILE, y // TILE
    #pg.draw.circle(sc, pg.Color('red'), *get_circle(grid_x, grid_y)) #рисует круг на месте клика мыши
    return (grid_x, grid_y)

def heuristic(a, b):
   return abs(a[0] - b[0]) + abs(a[1] - b[1])


# описание алгоритма на человеческом языке:
# (start, goal) - стартовая клетка (сначала именно старт, а потом клетка от которой идет текущий расчет), указанная клетка

# в queue формируются маршруты - последние клетки с ценой по каждому из возможных направлений
# из queue выбирается маршрут с наименьшей ценой и проверяются его соседи (цена соседей + цена посещеннйо клетки (cost_visited[cur_node] + neigh_cost)), после чего добавляются в queue
# и так далее пока не будет достигнута финальня точка
# формируется 2 списка - общий cost_visited (в нем все пути) и финальный visited (в котором только кратчайший и выглядит он как словарь в котором ключ (клетка): значение (пред.клетка)

def create_way(start, goal):
    global speed, grid

    #этот блок перебирает все клетки и присваивает им сложность прохождения
    graph = {}
    for y, row in enumerate(grid):
        for x, col in enumerate(row):
            graph[(x, y)] = graph.get((x, y), []) + get_neighbours(x, y)

    queue = [] #Это очередь. Или список приоритетных клеток. от которых далее идет расчет
    heappush(queue, (0, start)) #эта команда добавляет в очередь queue стартовую клетку
    cost_visited = {start: 0} #в этот справочник добавляются {координаты клетки: наименьшая цена пути до нее} {(0, 0): 0, (1, 0): 1, (0, 1): 1, (2, 0): 2, (1, 1): 2}
    visited = {start: 0} #а это итоговый маршрут. В нем первончальной клетка + соседи. Потом добавляется сосденяя с лучшей ценой + уже ее соседи. И так далее.
    while queue:
        cur_cost, cur_node = heappop(queue)

        #heappop(queue) - возвращает наименьшее значение из queue
        if cur_node == goal:
            break
        neighbours = graph[cur_node] #это проверяет соседние клетки
        for neighbour in neighbours:
            neigh_cost, neigh_node = neighbour
            #если соседняя клетка по диагонали, ее стоимость прохождения больше
            if heuristic(cur_node, neigh_node) == 1:
                new_cost = cost_visited[cur_node] + neigh_cost
            elif heuristic(cur_node, neigh_node) == 2:
                new_cost = cost_visited[cur_node] + neigh_cost*1.5
            #print(neigh_node)
            #print(abs(cur_node[0] + cur_node[1]))
            #print(abs(neigh_node[0]+neigh_node[1]))
            #print(abs((cur_node[0]+cur_node[1])-(neigh_node[0]+neigh_node[1])))
            if neigh_node not in cost_visited or new_cost < cost_visited[neigh_node]:
                #на этом этапе:
                #если новой клетки нет в списке посещенных (cost_visited)
                #или она есть, но ее цена ниже чем она есть в списке посещенных
                #то добавляется в список посещенных (cost_visited)
                #и добавляется в список приоритетных (queue)
                priority = new_cost + heuristic(neigh_node, goal) #heuristic - функция выше. Она выбирает клетку, которая ближе к той что выбрал пользователь (через сумму координат)
                heappush(queue, (priority, neigh_node)) #это ф-ция из библиотеки heapq. Она добавляет элелент (priority (цена), neigh_node (координаты клетки)) в список queue
                cost_visited[neigh_node] = new_cost
                visited[neigh_node] = cur_node #формирует итоговый маршрут который выглядит как справочник {(0, 6): None, (0, 5): (0, 6), (1, 6): (0, 6), (1, 5): (1, 6)}
                                               #(1, 5) - это ключ, по которому можно найти предмет - пред.клетку (1, 6)
                                               #это и передается на выход
    visited2 = 1
    return visited



#______________________________________________________________________________________________________________________
#клетка
class tile():
    def __init__ (self, x_pos, y_pos, type, closed, diff, image):
        self.x_pos = x_pos
        self.y_pos = y_pos
        self.type = type
        self.closed = closed
        self.diff = diff
        self.image = image

#типы клеток
def none(x, y):
    global tile
    tile.x_pos = x
    tile.y_pos = y
    tile.diff = 2
    grid[tile.y_pos][tile.x_pos] = tile.diff
    tile.type = "none"
    field[tile.y_pos][tile.x_pos] = tile.type
    tile.image = 'Grass1.png'
    field_images[tile.y_pos][tile.x_pos] = tile.image

def tree(x, y):
    global tile
    tile.x_pos = x
    tile.y_pos = y
    tile.diff = '-'
    grid[tile.y_pos][tile.x_pos] = tile.diff
    tile.type = "tree"
    field[tile.y_pos][tile.x_pos] = tile.type
    tile.image = 'Tree1.png'
    field_images[tile.y_pos][tile.x_pos] = tile.image

def stone(x, y):
    global tile
    tile.x_pos = x
    tile.y_pos = y
    tile.diff = 3
    grid[tile.y_pos][tile.x_pos] = tile.diff
    tile.type = "stone"
    field[tile.y_pos][tile.x_pos] = tile.type
    tile.image = 'rock1.png'
    field_images[tile.y_pos][tile.x_pos] = tile.image


def road(x, y):
    global tile
    tile.x_pos = x
    tile.y_pos = y
    tile.diff = 1
    grid[tile.y_pos][tile.x_pos] = tile.diff
    tile.type = "road"
    field[tile.y_pos][tile.x_pos] = tile.type
    tile.image = 'road1.jpg'
    field_images[tile.y_pos][tile.x_pos] = tile.image


#______________________________________________________________________________________________________________________
#создание поля
rnd_type = [none, tree, stone]

#сначала создаем "пустое" поле
def create_battlefield(cols, rows):
    x = 0
    for i in range(cols):
        x += 1
        y = 0
        for j in range(rows):
            grid[y].append(0)
            field[y].append(0)
            field_images[y].append(0)
            y += 1

#потом заполняем его клетками. Заменяем пустые клетки
def fill_battlefield(cols, rows):
    x = -1
    for i in range(cols):
        x += 1
        y = -1
        for j in range(rows):
            y += 1
            f = random.choices(rnd_type, weights=[5, 1, 1])
            rand_func = random.choice(f)
            rand_func(x, y)

#создание дороги. Доработать
#def crete_road():
#    end = (5, 15)
#    start = (23, 5)
#    visited = create_way(start, end)
#    print(visited)
#    for i in visited:
#        road(visited[1][1], visited[1][1])




create_battlefield(cols, rows)
fill_battlefield(cols, rows)
#crete_road()

#эта функция изменяет конретную клетку. На вход подается функция нужной клетки и координаты
#в данном случае меняет стартовую клетку на пустую.
def change_tile(tile, x, y):
    tile(x, y)
change_tile(none, start[0], start[1])

#______________________________________________________________________________________________________________________

#это необходимо для инициализации всех вложенных модулей
pg.init()

#окно программы
sc = pg.display.set_mode((1800, 1200))
clock = pg.time.Clock()


#позиция персонажа
def person_position(start):
    global TILE
    bg = pg.image.load('knight1.jpg').convert()
    bg = pg.transform.scale(bg, (TILE, TILE))
    sc.blit(bg, (start[0] * TILE, start[1] * TILE))

#отрисовка поля согласно созданной карте create_battlefield()
def explore():
    global TILE, cols, rows, mainfield_X, mainfield_Y
    mainfield_X_end = mainfield_X + cols * TILE
    mainfield_Y_end = mainfield_Y + rows * TILE
    main = pg.Rect(mainfield_X, mainfield_Y, mainfield_X_end-mainfield_X, mainfield_Y_end-mainfield_Y)
    pg.draw.rect(sc, (GREEN), main, 0)
    tile_x = -1
    for t in range(cols):
        tile_x += 1
        tile_y = -1
        for r in range(rows):
            tile_y += 1
            if field[tile_y][tile_x] != "none":
                bg = pg.image.load(field_images[tile_y][tile_x]).convert()
                bg = pg.transform.scale(bg, (TILE, TILE))
                sc.blit(bg, (mainfield_X + TILE * (tile_x), mainfield_Y + TILE * (tile_y)))
            # f1 = pg.font.Font(None, 24)
            # text1 = f1.render(str(tile_x-1) + '-' + str(tile_y-1), 1, (180, 0, 0))
            # sc.blit(text1, (mainfield_X+TILE*(tile_x-1), mainfield_Y+TILE*(tile_y-1)))
    for i in range(0, int(rows)+1):
        pg.draw.line(sc, (0, 0, 0), (mainfield_X, mainfield_Y + i * TILE), (mainfield_X_end, mainfield_Y + i * TILE))
    for j in range(0, int(cols)+1):
        pg.draw.line(sc, (0, 0, 0), (mainfield_X + j * TILE, mainfield_Y), (mainfield_X + j * TILE, mainfield_Y_end))





#создание пути передвижения
#меняет позицию, если проверка прохождения была успешна
#используется костыль. функция перемещаетна 1 клетку больше. По этому приходится делать остечку по diff >= speed, а не diff > speed
#оно работает. Но надопонять в чем дело
def cp():
    global path_head, path_segment, visited, start, grid
    print(visited)
    path = []
    #берем указанную клетку (path_segment), ищем ее пару. Пару назначам path_segment и ищем ее пару.
    while path_segment and path_segment in visited:
        print(visited[path_segment])
        path_segment = visited[path_segment]
        path.append(path_segment) #создаем путь
    print(path)
    diff = 0
    if path == []: #это костыль. Если цель непроходима (напр.Дерево), то в функцию путь не передается.
        path = []
    else:
        path[-1] = path[-2]
    x = -2 # -2 потому-что нам нужна 2е значение с конца.
    #цикл определяет клетку в которой сумма сложностей пройенных клеток становится выше скорости. Или если финальная клетка равная новой
    for i in path:
        if path_head == start: #если новая позиция == стартовой, цикл обрывается что-бы не было ошибки
            break
        else: #проверяем сложность клетки.
            new_pos = path[x] #перемещаем объект на следующую клетку маршрута
            if heuristic(path[x], path[x+1]) == 1: #если клетки соседние по горизонтали
                diff += grid[path[x][1]][path[x][0]] #добавляем сложность клетки в сумму сложностей пройденных клеток
            elif heuristic(path[x], path[x+1]) == 2: #если клетки соседние по диагонали
                diff += grid[path[x][1]][path[x][0]]*1.5 #добавляем сложность клетки в сумму сложностей пройденных клеток
            if diff >= speed: #если сложность выше скорости
                start = new_pos #объявляем новую позицию объекта в данной клетке
            elif new_pos == path[0]: #если финальная клетка в маршруте == выбранной
                start = path_head #объявляем новую позицию объекта в данной клетке
            else:
                x -= 1 #проверяем слудующуюклетку в маршруте и повторяем цикл
    return start

# показывает путь без изменения позиции
# простыми словами
# visited - словарь с списком соседей {(0, 6): None, (0, 5): (0, 6), (1, 6): (0, 6), (1, 5): (1, 6), (1, 7): (1, 6), (2, 7): (1, 7)}
# в данном примере (2, 7) - это финальная точка. Цикл ниже перебирает клетки от ключа (2, 7) ищет привязанную к ней клетку (1, 7) и так далее пока не закончится.
def path():
    mouse_pos = get_mouse_pos()
    goal = mouse_pos
    path_head = goal
    path_segment = goal
    visited = create_way(start, mouse_pos)
    while path_segment and path_segment in visited:
        pg.draw.circle(sc, pg.Color('blue'), *get_circle(*path_segment))
        path_segment = visited[path_segment]
        pg.draw.circle(sc, pg.Color('magenta'), *get_circle(*path_head))
        pg.draw.circle(sc, pg.Color('green'), *get_circle(*start))




#основной цикл
while True:
    #сделать функцию которая указывает какие элементы нужны обновлять постоянно, и обновляет их.
    #например отрисовка пути нужна только при активации персонажа и только в бою. Вне данных условий, ее отключить
    pg.draw.circle(sc, pg.Color('green'), *get_circle(*start))
    explore()
    person_position(start)
    path()

    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
            sys.exit()
        # этот блок отвечает за передвижение. В дальнейшем, так его и выделить
        elif event.type == pg.MOUSEBUTTONDOWN:
            mouse_clik = get_mouse_pos()
            goal = mouse_clik
            path_head = goal
            path_segment = goal
            visited = create_way(start, mouse_clik)
            if event.button == 1:
                cp()


    pg.display.flip()
    clock.tick(30)

    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
