import pygame as pg
from heapq import *
import random
import sys


#это большой блок для отриссовки "змейки" и поиска пути. онять до конца как он работаю
#функция создания круга для "змейки"
def get_circle(x, y):
    return (x * TILE + TILE // 2, y * TILE + TILE // 2), TILE // 4


#определить соседние клетки
def get_neighbours(x, y):
    check_neighbour = lambda x, y: True if 0 <= x < cols and 0 <= y < rows and grid[0][0] != 2 else False
    ways = [-1, 0], [0, -1], [1, 0], [0, 1]#, [-1, -1], [1, -1], [1, 1], [-1, 1]
    return [((grid[y + dy][x + dx]), (x + dx, y + dy)) for dx, dy in ways if check_neighbour(x + dx, y + dy) and (grid[y + dy][x + dx]) != 9]

    #(grid[y + dy][x + dx]) - эта команда определяет стоимость прохождения

    #Если в конце x и y (или dx, dy) умножить на какое-то значение, это ограничивает длинну змейки. Понять как это работает, чтобы проверка была не на всей карте, а по нужной длинне
    #dx*11 - означет что длинна уменьшиться на 11 от противоположного края
    #dy*4 - означает что длинна уменьшиться на 3 от верхнего и нижнего края



def get_click_mouse_pos():
    x, y = pg.mouse.get_pos()
    grid_x, grid_y = x // TILE, y // TILE
    pg.draw.circle(sc, pg.Color('red'), *get_circle(grid_x, grid_y))
    click = pg.mouse.get_pressed()
    return (grid_x, grid_y) if click[0] else False

def get_mouse_pos():
    x, y = pg.mouse.get_pos()
    grid_x, grid_y = x // TILE, y // TILE
    pg.draw.circle(sc, pg.Color('red'), *get_circle(grid_x, grid_y))
    return (grid_x, grid_y)




def heuristic(a, b):
   return abs(a[0] - b[0]) + abs(a[1] - b[1])


def create_way(start, goal, graph):
    global speed
    queue = []
    heappush(queue, (0, start))
    cost_visited = {start: 0}
    visited = {start: None}
    while queue:
        cur_cost, cur_node = heappop(queue)
        if cur_node == goal:
            break
        neighbours = graph[cur_node]
        for neighbour in neighbours:
            neigh_cost, neigh_node = neighbour
            new_cost = cost_visited[cur_node] + neigh_cost

            if neigh_node not in cost_visited or new_cost < cost_visited[neigh_node]:
                priority = new_cost + heuristic(neigh_node, goal)
                heappush(queue, (priority, neigh_node))
                cost_visited[neigh_node] = new_cost
                visited[neigh_node] = cur_node
    return visited

def change_pos(start_pos, end_pos, graph):
    global speed, tile, grid, start
    queue = []
    heappush(queue, (0, start_pos))
    cost_visited = {start_pos: 0}
    visited2 = {start_pos: None}
    while queue:
        cur_cost, cur_node = heappop(queue)
        if cur_node == end_pos:
            break
        neighbours = graph[cur_node]
        for neighbour in neighbours:
            neigh_cost, neigh_node = neighbour
            new_cost = cost_visited[cur_node] + neigh_cost

            if neigh_node not in cost_visited or new_cost < cost_visited[neigh_node]:
                priority = new_cost + heuristic(neigh_node, end_pos)
                heappush(queue, (priority, neigh_node))
                cost_visited[neigh_node] = new_cost
                visited2[neigh_node] = cur_node

    keys = [key for key in cost_visited if cost_visited[key] >= int(speed)-1]
    try:
        if grid[mouse_clik[1]] [mouse_clik[0]] != 9:
            try:
                key1 = abs(keys[0][0] - mouse_clik[0]) + abs(keys[0][1] - mouse_clik[1])
                key2 = abs(keys[1][0] - mouse_clik[0]) + abs(keys[1][1] - mouse_clik[1])
                key3 = abs(keys[2][0] - mouse_clik[0]) + abs(keys[2][1] - mouse_clik[1])
                key123 = (key1, key2, key3)
                if min(key123) == key1:
                    start_pos = keys[0]
                elif min(key123) == key2:
                    start_pos = keys[1]
                else:
                    start_pos = keys[2]
            except IndexError:
                    start_pos = end_pos
    except IndexError:
        print('1111')
    person_position(start_pos)
    start = start_pos
    return start




#матрица проходимости. Каждое число - шкала X.
grid = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',]



cols, rows = 23, 13
TILE = 50

#начало поля. Это на будущее для общего смещения поля
mainfield_X = 0
mainfield_Y = 0


#клетка
class tile():
    def __init__ (self, x, y, x_pos, y_pos, type, closed, diff):
        self.x = x
        self.y = y
        self.x_pos = x_pos
        self.y_pos = y_pos
        self.type = type
        self.closed = closed
        self.diff = diff

#типы клеток
def none():
    global field, x, y, xy, tile, grid
    tile.type = "none"
    tile.x_pos = mainfield_X + TILE * (tile.x - 1)
    tile.y_pos = mainfield_Y + TILE * (tile.y - 1)
    tile.diff = 1
    none = tile(tile.x, tile.y, tile.x_pos, tile.y_pos, tile.type, "-", tile.diff)
    #print(str(xy) + ": " + str(vars(none)))
    field[xy] = none
    grid[tile.y-1] = str(grid[tile.y-1]) + str(tile.diff)
    return field, grid

def tree():
    global field, x, y, xy, tile, grid
    tile.type = "tree"
    tile.x_pos = mainfield_X + TILE * (tile.x - 1)
    tile.y_pos = mainfield_Y + TILE * (tile.y - 1)
    tile.diff = 9
    tree = tile(tile.x, tile.y, tile.x_pos, tile.y_pos, tile.type, "+", tile.diff)
    #print(str(xy) + ": " + str(vars(tree)))
    field[xy] = tree
    grid[tile.y-1] = str(grid[tile.y-1]) + str(tile.diff)
    return field, grid

def stone():
    global field, x, y, xy, tile, grid
    tile.type = "stone"
    tile.x_pos = mainfield_X + TILE * (tile.x - 1)
    tile.y_pos = mainfield_Y + TILE * (tile.y - 1)
    tile.diff = 2
    stone = tile(tile.x, tile.y, tile.x_pos, tile.y_pos, tile.type, "+", tile.diff)
    #print(str(xy) + ": " + str(vars(stone)))
    field[xy]=stone
    grid[tile.y-1] = str(grid[tile.y-1]) + str(tile.diff)
    return field, grid






#создание поля
rnd_type = [none, tree, stone]
tile.x=0
tile.y=0
xy = 0
field = {
}
def create_battlefield(x,y):
    global xy
    for i in range(x):
        tile.x += 1
        tile.y = 0
        for j in range(y):
            tile.y += 1
            xy = str(tile.x) + "-" + str(tile.y)
            f = random.choices(rnd_type, weights=[5, 1, 1])
            rand_func = random.choice(f)
            rand_func()

#перезагрузка поля
def reset_battlefield():
    global tile, xy, field
    tile.x = 0
    tile.y = 0
    xy = 0
    field = {
    }
    return tile, xy, field




#отрисовка поля. Общий старт
create_battlefield(cols, rows)

#это необходимо для инициализации всех вложенных модулей
pg.init()

#окно программы
sc = pg.display.set_mode((1800, 1200))
clock = pg.time.Clock()


grid = [[int(char) for char in string] for string in grid]
# adjacency dict
graph = {}
#enumerate() . Если range() позволяет получить только индексы элементов списка, то enumerate() – сразу индекс элемента и его значение.
for y, row in enumerate(grid):
    for x, col in enumerate(row):
        graph[(x, y)] = graph.get((x, y), []) + get_neighbours(x, y)



speed = 10

#посещенная позиция
start = (0, 7)
goal = start
queue = []
heappush(queue, (0, start)) #это команда из библиотеки heapq. Изучить
visited = {start: None} #словарь посещенных позиций. При поиске пути

visited2 = {start: None} #словарь посещенных позиций. При поиске пути



class person_position:
    def __init__(self, x, y, xx, yy, color):
        self.x = x
        self.y = y
        self.xx = xx
        self.yy = yy
        self.color = color

#позиция персонажа
start_pos_x = mainfield_X
start_pos_y = mainfield_Y

player_position = person_position(start_pos_x, start_pos_y, TILE, TILE, (22, 22, 22))
enemy_position = person_position(start_pos_x, start_pos_y, TILE, TILE, (55, 55, 55))

start = (0, 7)
#заполнение клетки
def person_position(start):
    global TILE
    bg = pg.image.load('knight1.jpg').convert()
    bg = pg.transform.scale(bg, (TILE, TILE))
    sc.blit(bg, (start[0] * TILE, start[1] * TILE))




WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (125, 125, 125)
LIGHT_BLUE = (64, 128, 255)
GREEN = (0, 200, 64)
YELLOW = (225, 225, 0)
PINK = (230, 50, 230)
ForestGreen = (34, 139, 34)
RED = (255, 0, 0)




def explore():
    global TILE, cols, rows, mainfield_X, mainfield_Y
    tile_x = 0
    tile_y = 0

    mainfield_X_end = mainfield_X + cols * TILE
    mainfield_Y_end = mainfield_Y + rows * TILE

    main = pg.Rect(mainfield_X, mainfield_Y, mainfield_X_end-mainfield_X, mainfield_Y_end-mainfield_Y)
    pg.draw.rect(sc, (GREEN), main, 0)

    for i in range(0, int(rows)+1):
        pg.draw.line(sc, (0, 0, 0), (mainfield_X, mainfield_Y + i * TILE), (mainfield_X_end, mainfield_Y + i * TILE))
    for j in range(0, int(cols)+1):
        pg.draw.line(sc, (0, 0, 0), (mainfield_X + j * TILE, mainfield_Y), (mainfield_X + j * TILE, mainfield_Y_end))
    for t in range(cols):
        tile_x += 1
        tile_y = 0
        for r in range(rows):
            tile_y += 1
            xxx = field.get(str(tile_x) + "-" + str(tile_y)).x
            yyy = field.get(str(tile_x) + "-" + str(tile_y)).y
            if field.get(str(tile_x) + "-" + str(tile_y)).type == "stone":
                bg = pg.image.load('rock1.png').convert()
                bg = pg.transform.scale(bg, (TILE, TILE))
                sc.blit(bg, (mainfield_X + TILE * (xxx - 1), mainfield_Y + TILE * (yyy - 1)))
                f1 = pg.font.Font(None, 24)
                tx = grid[tile_y-1]
                tx2 = tx[tile_x-1]
                text1 = f1.render(str(tx2), 1, (180, 0, 0))
                sc.blit(text1, (mainfield_X+TILE*(xxx-1), mainfield_Y+TILE*(yyy-1)))
            elif field.get(str(tile_x) + "-" + str(tile_y)).type == "tree":
                bg = pg.image.load('Tree1.png').convert()
                bg = pg.transform.scale(bg, (TILE, TILE))
                sc.blit(bg, (mainfield_X+TILE*(xxx-1), mainfield_Y+TILE*(yyy-1)))
                f1 = pg.font.Font(None, 24)
                tx = grid[tile_y - 1]
                tx2 = tx[tile_x - 1]
                text1 = f1.render(str(tx2), 1, (180, 0, 0))
                sc.blit(text1, (mainfield_X + TILE * (xxx - 1), mainfield_Y + TILE * (yyy - 1)))

#создание пути передвижения



#показывает путь без изменения позиции

def cp():
    way = []
    global path_headd, path_segmentt, visited, start, grid
    while path_segmentt and path_segmentt in visited:
        path_segmentt = visited[path_segmentt]
        way.append(path_segmentt)

    way2 = way[:-1]
    print(way2)
    diff = 0
    x = -2
    for i in way2:
        new_pos = way2[x]
        diff += grid[way2[x][1]][way2[x][0]]
        print(diff)
        print(path_headd)
        print(new_pos)
        print(start)
        print("-")
        if diff >= speed:
            start = new_pos
        elif new_pos == way2[0]:
            start = path_headd
        else:
            x -= 1

    return start



#меняет позицию, если проверка прохождения была успешна
def path():
    global path_head, path_segment, visited
    while path_segment and path_segment in visited:
        pg.draw.circle(sc, pg.Color('blue'), *get_circle(*path_segment))
        path_segment = visited[path_segment]
        pg.draw.circle(sc, pg.Color('magenta'), *get_circle(*path_head))
        pg.draw.circle(sc, pg.Color('green'), *get_circle(*start))



while True:
    pg.draw.circle(sc, pg.Color('green'), *get_circle(*start))
    explore()
    person_position(start)

    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
            sys.exit()
        elif event.type == pg.MOUSEMOTION:
            mouse_move = get_mouse_pos()
            goal = mouse_move
            visited = create_way(start, mouse_move, graph)
        elif event.type == pg.MOUSEBUTTONDOWN:
            if event.button == 1:
                mouse_clik = get_click_mouse_pos()
                goall = mouse_clik
                path_segmentt = goall
                path_headd = goall
                if mouse_clik:
                    cp()





    # отрисовка линии


    path_head = goal  # конец линии. Голова
    path_segment = goal  # элементы линии. сегмент
    path()


    pg.display.flip()
    clock.tick(30)



    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
